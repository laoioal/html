js # day03


- slice
	배열의 특정 범위에 속하는 원소만 선택하여 배열 생성
	
	var kdata = ['서울', '부산', '구포', '대구', '인천', '대전', '세종'];
		 index		0		1		2		3		4		5		6
		 index		-7		-6		-5		-4		-3		-2		-1
		 
	var str1 = kdata.slice(1, 4);
		==> 인덱스 1부터 인덱스 4전까지 산출
	
	var str2=kdata.slice(2, -1);
		==> 인덱스 2부터 인덱스 -1전까지 산출
		
-------------------------------------------------------------------------------------------------
- splice
	배열의 원소 추가 또는 제거

	var str4 = kdata.splice(3, 4);
		==> 인덱스 3부터 4개를 잘라서 산출 // 기존 데이터에는 str4가 제외되어 산출됨
	
	var str5 = kdata.splice(2, 2, '강릉', '아산');
		==> 인덱스 2부터 2개를 잘라서 산출 // 기존 데이터에는 str5 제외되고 강릉, 아산이 그 자리에 위치함
	
	var str6 = kdata.splice(2, Number.MAX_VALUE);
		==> 이처럼 Number.MAX_VALUE를 이용하여 마지막 자리까지 산출도 가능

=============================================================================================================
- push & pop
	push 메소드: 배열의 마지막 위치에 데이터를 추가하고 배열의 길이를 반환
	pop 메소드: 배열의 마지막 위치에 있는 데이터를 삭제하고 삭제한 데이터를 반환

	var kdata = ['서울', '부산', '구포', '대구', '대전'];
	
	var p1 = kdata.push('청주', '세종'); 
		==> 기존데이터의 마지막 위치에 데이터를 추가하고 배열의 길이를 반환
		
	var p2 = kdata.pop(); 
		==> 배열의 마지막 위치에 있는 데이터를 삭제하고 삭제한 데이터 반환 // 기존 데이터는 p2가 삭제되어 산출
		
--------------------------------------------------------------------------------------------------------
- shift & unshift
	shift 메소드: 배열의 맨 처음 위치에 데이터를 삭제하고 배열의 삭제된 데이터 반환
	unshift 메소드: 배열의 맨 처음 위치에 데이터를 삽입하고 배열의 길이 반환
	
================================================================================================================
- forEach
	배열을 반복하며 저장된 데이터를 조회
	
	 var kdata = ['서울', '부산', '청주', '대구']; 
	
	 function printArr(index, item) {
		 document.write("배열 데이터 [" + index + "] : " + item + "<br>");
	 }
	 kdata.forEach(printArr);
	 
	 ==> 산출값
	 	배열 데이터 [서울] : 0
		배열 데이터 [부산] : 1
		배열 데이터 [청주] : 2
		배열 데이터 [대구] : 3
	 				
	 
	 function printArr(item, index) {
		 document.write("배열 데이터 [" + index + "] : " + item + "<br>");
	 }
	 kdata.forEach(printArr);
	 
	 ==> 산출값
	 	배열 데이터 [0] : 서울
		배열 데이터 [1] : 부산
		배열 데이터 [2] : 청주
		배열 데이터 [3] : 대구
		
		
		==> item, index순으로 작성해야 원하는 데이터를 얻을 수 있다.
		
		
		
		
	var data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; 
	
	var gop = 1;
	function addArr(value) {
		gop *= value;
	}
	data.forEach(addArr); 
	document.write("배열 데이터 곱 :" + gop + "<p/>");
	
		==> 3628800
		
============================================================================================================================
-- map
	배열의 데이터를 함수의 인자로 전달하고 함수의 수행 결과를 반환 받아 새로운 배열 생성
	
	var data=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; 
	function mapArr(value) {
		return value*value; 
	}
	var mapdata=data.map(mapArr); 
	 
		==> map 메소드 적용 배열 :1,4,9,16,25,36,49,64,81,100
	
============================================================================================================================
-- filter
	 배열의 데이터 중에 조건이 참인 데이터만 반환하여 새로운 배열 생성
	 
	 var arr = [10, '20', 30, '50', '70', 90];


	function func01(value) {
		return 'number' == (typeof value);
	}
	var numArr = arr.filter(func01);
	
		==> value의 타입이 number인 데이터만 모아서 새로운 배열 생성 // numArr : 10,30,90

============================================================================================================================
-- indexOf & lastIndexOf
	배열의 데이터를 검색하여 인덱스 위치를 반환
		• indexOf 메소드: 검색 시작 위치를 지정할 수 있음
		• lastIndexOf 메소드: 배열의 맨 마지막 원소부터 검색 시작
	
	var data=[];
	
	for(var i = 0; i < 10; i++) {
		data[i] = i * 10 + 10;
		
	}
	document.write('<h3 class="w3-text-indigo">배열 데이터 : [' + data + ']</h3>');
		==> 배열 데이터 : [10,20,30,40,50,60,70,80,90,100]
		
	document.write('<h3 class="w3-text-blue">처음부터 검색한 30의 인덱스 : ' + data.indexOf(30) + '</h3>');
		==> 처음부터 검색한 30의 인덱스 : 2
		
	document.write('<h3 class="w3-text-green">마지막에서 검색한 30의 인덱스 : ' + data.lastIndexOf(30, -2) + '</h3>');
		==> 마지막에서 검색한 30의 인덱스 : 2
		
	document.write('<h3 class="w3-text-purple">세 번째부터 검색한 30의 인덱스 : ' + data.indexOf(30, 5) + '</h3>');
		==> 세 번째부터 검색한 30의 인덱스 : -1	// 조회할 수 없을경우 -1을 리턴
	 
=============================================================================================================================
-- 연관배열	 
	 생성방법 ]
	 	var 변수 = {'키값1':데이터1, '키값2':데이터2, '키값3':데이터3, ....}
	 	
	 var blackpink = {
		'b1': '제니', 'b2' : '리사'	, 'b3': '로제'
	};
	
	// 데이터를 꺼내는 방법
	document.write('<h3 class="w3-text-pink w3-center">' + blackpink.b2 + '</h3>')
	document.write('<h3 class="w3-text-purple w3-center">' + blackpink['b2'] + '</h3><hr>')	
	
	// 데이터 추가
	blackpink.b1 = 'jennie';
		==> 한개의 키에는 한개의 값만 가질 수 있으므로 b1에는 jennin가 들어가게 된다.
	blackpink['b4'] = '지수';
	
	 
	// 출력
	document.write('<h3 class="w3-text-indigo w3-center">' + blackpink.b3 + '</h3>')
	document.write('<h3 class="w3-text-blue w3-center">' + blackpink['b4'] + '</h3>') 
	 
========================================================test11 참고=====================================================================
*******substring / substr 차이 확인하기
	String charAt(int) - 지정된 위치의 글자를 리턴
	int indexOf(String) - 문자열 앞에서부터 파라미터로 주어진 글자를 검색하여 위치를 알려준다. / 검색결과가 없는 경우 -1을 리턴
	int lastIndexOf(String) - 문자열 뒤에서부터 파라미터로 주어진 글자를 검색하여 위치를 알려준다. / 검색결과가 없는 경우 -1을 리턴
	String substring(int, int) - 문자열에서 첫번째 파라미터의 위치부터 두번째 파라미터 앞 인덱스까지 추출 / 두번째 파라미터가 없는경우 끝까지 추출
	String toUpperCase() - 대문자로 변환
	String toLowerCase() - 소문자로 변환
	String slice(int, int) -  첫번째 파라미터 만큼 문자를 자르고 두번째 파라미터 이후의 문자를 자른 후 남은 문자 반환
	String replace(String, String) - 첫번째 파라미터의 문자를 찾아 두번째 파라미터로 바꾼 후 반환
	String match(String) - 파라미터의 문자를 찾아 최초 찾은 문자를 반환 / 없으면 null 반환
	int search(String) - 왼쪽부터 파라미터의 문자를 찾아 최초로 일치하는 인덱스 번호 반환
	String substr(int, int) - 첫번째 파라미터 위치에서부터 두번째 파라미터 개수만큼 문자열을 반환
	Array split(String) - 파라미터의 문자를 기준으로 문자데이터를 나누어 배열에 저장해서 반환
	String concat(String) - 문자열에 파라미터로 입력한 문자열을 더해서 반환
	String trim() - 문자 앞 뒤의 공백 문자를 삭제해서 반환
	 
	 
	 
	 
	 
	 
	 
	 
 ============================================================================================================================
 ============================================================================================================================
 ============================================================================================================================
 ============================================================================================================================
 ============================================================================================================================
 ============================================================================================================================
 ============================================================================================================================
 ============================================================================================================================
 ============================================================================================================================
 ============================================================================================================================
 